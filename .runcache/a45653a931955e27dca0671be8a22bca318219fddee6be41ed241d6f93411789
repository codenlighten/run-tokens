{"kind":"code","props":{"OP_CODES":{"OP_0":0,"OP_0NOTEQUAL":146,"OP_1":81,"OP_10":90,"OP_11":91,"OP_12":92,"OP_13":93,"OP_14":94,"OP_15":95,"OP_16":96,"OP_1ADD":139,"OP_1NEGATE":79,"OP_1SUB":140,"OP_2":82,"OP_2DROP":109,"OP_2DUP":110,"OP_2OVER":112,"OP_2ROT":113,"OP_2SWAP":114,"OP_3":83,"OP_3DUP":111,"OP_4":84,"OP_5":85,"OP_6":86,"OP_7":87,"OP_8":88,"OP_9":89,"OP_ABS":144,"OP_ADD":147,"OP_AND":132,"OP_BIN2NUM":129,"OP_BOOLAND":154,"OP_BOOLOR":155,"OP_CAT":126,"OP_CHECKMULTISIG":174,"OP_CHECKMULTISIGVERIFY":175,"OP_CHECKSIG":172,"OP_CHECKSIGVERIFY":173,"OP_CODESEPARATOR":171,"OP_DEPTH":116,"OP_DIV":150,"OP_DROP":117,"OP_DUP":118,"OP_ELSE":103,"OP_ENDIF":104,"OP_EQUAL":135,"OP_EQUALVERIFY":136,"OP_FALSE":0,"OP_FROMALTSTACK":108,"OP_GREATERTHAN":160,"OP_GREATERTHANOREQUAL":162,"OP_HASH160":169,"OP_HASH256":170,"OP_IF":99,"OP_IFDUP":115,"OP_INVALIDOPCODE":255,"OP_INVERT":131,"OP_LESSTHAN":159,"OP_LESSTHANOREQUAL":161,"OP_LSHIFT":152,"OP_MAX":164,"OP_MIN":163,"OP_MOD":151,"OP_MUL":149,"OP_NEGATE":143,"OP_NIP":119,"OP_NOP":97,"OP_NOP1":176,"OP_NOP10":185,"OP_NOP2":177,"OP_NOP3":178,"OP_NOP4":179,"OP_NOP5":180,"OP_NOP6":181,"OP_NOP7":182,"OP_NOP8":183,"OP_NOP9":184,"OP_NOT":145,"OP_NOTIF":100,"OP_NUM2BIN":128,"OP_NUMEQUAL":156,"OP_NUMEQUALVERIFY":157,"OP_NUMNOTEQUAL":158,"OP_OR":133,"OP_OVER":120,"OP_PICK":121,"OP_PUBKEY":254,"OP_PUBKEYHASH":253,"OP_PUSHDATA1":76,"OP_PUSHDATA2":77,"OP_PUSHDATA4":78,"OP_RETURN":106,"OP_RIPEMD160":166,"OP_ROLL":122,"OP_ROT":123,"OP_RSHIFT":153,"OP_SHA1":167,"OP_SHA256":168,"OP_SIZE":130,"OP_SPLIT":127,"OP_SUB":148,"OP_SWAP":124,"OP_TOALTSTACK":107,"OP_TRUE":81,"OP_TUCK":125,"OP_VERIFY":105,"OP_WITHIN":165,"OP_XOR":134},"deps":{"Hex":{"$jig":"727e7b423b7ee40c0b5be87fba7fa5673ea2d20a74259040a7295d9c32a90011_o1"}},"location":"_o1","nonce":2,"origin":"61e1265acb3d93f1bf24a593d70b2a6b1c650ec1df90ddece8d6954ae3cdd915_o1","owner":"1PytriYokKN3GpKw84L4vvrGBwUvTYzCpx","satoshis":0},"src":"function asm (s) {\n  const parts = s.split(' ')\n  let out = []\n\n  for (const part of parts) {\n    // If one of our predefined op-codes\n    if (typeof asm.OP_CODES[part] !== 'undefined') {\n      out.push(asm.OP_CODES[part])\n      continue\n    }\n\n    // Hex data\n    const bytes = Hex.stringToBytes(part.length === 1 ? '0' + part : part)\n\n    // OP_0\n    if (bytes.length === 1 && bytes[0] === 0) {\n      out.push(bytes[0]) // OP_0\n      continue\n    }\n\n    // OP_1-OP_16\n    if (bytes.length === 1 && bytes[0] >= 1 && bytes[0] <= 16) {\n      out.push(bytes[0] + 0x50)\n      continue\n    }\n\n    // OP_PUSH+[1-75] <bytes>\n    if (bytes.length <= 75) {\n      out = out.concat(bytes.length).concat(bytes)\n      continue\n    }\n\n    // OP_PUSHDATA1 <len> <bytes>\n    if (bytes.length < 256) {\n      out = out.concat(asm.OP_CODES.OP_PUSHDATA1).concat([bytes.length]).concat(bytes)\n      continue\n    }\n\n    const floor = x => parseInt(x.toString(), 10)\n\n    // OP_PUSHDATA2 <len> <bytes>\n    if (bytes.length < 256 * 256) {\n      const len = [floor(bytes.length / 256), bytes.length % 256]\n      out = out.concat(asm.OP_CODES.OP_PUSHDATA2).concat(len).concat(bytes)\n      continue\n    }\n\n    // OP_PUSHDATA4 <len> <bytes>\n    const len = [\n      floor(bytes.length / 256 / 256 / 256),\n      floor(bytes.length / 256 / 256) % 256,\n      floor(bytes.length / 256) % 256,\n      bytes.length % 256\n    ]\n    out = out.concat(asm.OP_CODES.OP_PUSHDATA4).concat(len).concat(bytes)\n    continue\n  }\n\n  return Hex.bytesToString(out)\n}","version":"04"}